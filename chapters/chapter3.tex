\chapter{Especificação e Arquitetura do Sistema}
\label{chap:metodos}

\begin{introduction}
Este capítulo descreve os requisitos (funcionais e não funcionais) que o sistema precisa de seguir, bem como uma descrição da sua arquitetura
\end{introduction}

\section{Requisitos do Sistema}

\subsection{Requisitos Funcionais}

\begin{enumerate}
    \item[FR1] O sistema deve ser capaz de receber e agrupar dados de várias fontes associadas ao mesmo utilizador.
    \item[FR2] O sistema deve ser capaz de receber e processar dados provindos do teclado, câmara ou smartwatch (WearOS).
    \item[FR3] O sistema deve permitir ao utilizador visualizar os dados recolhidos tanto em tempo real como após a sessão terminar.
    \item[FR4] O sistema deve permitir o controlo de todos os sensores associados ao utilizador de forma centralizada.
    \item[FR5] O sistema deve ser capaz de identificar os sensores disponíveis e monitorizar em tempo real que sensores estão a enviar dados.
    \item[FR6] O sistema deve ser capaz de detetar falhas em sensores.
    \item[FR7] O sistema deve ser capaz de gerar uma estimativa do nível de atenção do utilizador num dado momento com base nos dados disponíveis.
    \item[FR8] O sistema deve indicar visualmente nos gráficos os intervalos de tempo em que um dado sensor não esteve a enviar dados.
\end{enumerate}

\subsection{Requisitos Não Funcionais}

\begin{enumerate}
    \item[NFR1] O sistema deve funcionar corretamente mesmo quando apenas um subconjunto dos sensores é utilizado.
    \item[NFR2] Cada nó consumidor deve ser capaz de ingerir pelo menos 10 mensagens por segundo.
    \item[NFR3] Todos os componentes não locais devem poder escalar horizontalmente e/ou verticalmente se necessário.
    \item[NFR4] O sistema deve detetar e reportar uma falha num sensor em menos de 1 segundo.
    \item[NFR5] O sistema deve permitir a adição de mais sensores sem modificar a estrutura pré-existente.
    \item[NFR6] Os plugins de cada sensor devem recolher e enviar dados de forma autónoma, sem depender do funcionamento de outros plugins.
    \item[NFR7] O sistema deve permitir a substituição do modelo preditivo sem que isto altere o funcionamente do resto do sistema.
    \item[NFR8] O modelo preditivo deve gerar uma previsão (mesmo que menos precisa) mesmo que os dados de um ou mais sensores estejam em falta.
\end{enumerate}

\section{Visão geral da arquitetura}

O sistema presente na Figura~\ref{fig:sys_arq} possui uma arquitetura descentralizada à base de eventos, que pode ser divido em 2 secções: \textbf{componentes locais} (que são executados no computador ou wearable do próprio utilizador) e \textbf{componentes externos} que vão ser executados através de Docker Swarm de modo a simular um ambiente distribuído em cloud.

\begin{itemize}
    \item \textbf{Componentes locais:}
    \begin{itemize}
        \item \textbf{App para Desktop:} Esta app feita em Python será o principal ponto de acesso por parte do utilizador e permitirá ao utilizador não só controlar todos os sensores de forma centralizada (iniciar ou parar uma sessão e definir que sensores serão utilizados em cada sessão), mas também ver os valores medidos pelos sensores e a evolução do seu nível de atenção ao longo de cada sessão.
        \item \textbf{Plugins para sensores locais:} Cada sensor presente no computador do utilizador (teclado e câmara) terá o seu próprio plugin responsável por recolher os dados do respetivo sensor, remover informação irrelevante e enviar as medições para o Kafka. Estes plugins serão controlados diretamente pelo utilizador através da app.
        \item \textbf{Broker MQTT local:} Este broker (nativo do próprio python) servirá para comunicação entre a app e o smartwatch (visto que o smartwatch disponibilizado pelo orientador não expõe uma interface \ac{BLE}), permitindo o envio de comandos e a troca de informação entre estes.
        \item \textbf{App para WearOS:} Esta app em Kotlin permitirá a medição de \ac{HRV} (extrapolado através dos batimentos por minuto) e o envio destes para o Kafka (através do REST Proxy).
    \end{itemize}
    \item \textbf{Componentes externos:}
    \begin{itemize}
        \item \textbf{Kafka:} O Kafka permite gerir o fluxo de dados entre os plugins e os respetivos consumidores, garantindo a entrega de mensagens de forma escalável e tolerante a falhas.
        \begin{itemize}
            \item \textbf{Kafka REST Proxy:} Adaptador que permite o acesso ao Kafka através duma interface \ac{REST}. Este adaptador é utilizado pela app para WearOS, visto que a versão de Kotlin para WearOS e Android não possui uma biblioteca de sistema (Management) necessária para o uso da biblioteca de Kafka.
        \end{itemize}
        \item \textbf{Nós Consumidores:} Estes nós escritos em Python têm como objetivo receber os dados enviados pelos sensores (através de Kafka) e processá-los antes de os inserir no InfluxDB. Cada nó processa um tipo de sensor diferente, permitindo assim escalar horizontalmente estes componentes de forma independente.
        \item \textbf{InfluxDB:} Base de dados Time Series onde os dados são armazenados após serem processados e alimenta a app para desktop e o componente preditivo. InfluxDB em particular foi escolhido visto ser a base de dados Time Series com a melhor documentação e suporte que encontrei até agora.
        \item \textbf{Modelo de previsão do estado psicológico:} Componente responsável por utilizar os dados presentes no InfluxDB de modo a estimar o estado psicológico do utilizador. Devido ao facto de que o modelo em si não é o foco do trabalho, bem como do esforço necessário para recolher os dados necessários, este componente não irá utilizar um modelo de Inteligência artificial, mas sim um modelo comparativo.
    \end{itemize}
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{figs/Dissertation_arquitecture.png}
    \caption{Visão geral da arquitetura do sistema}
    \label{fig:sys_arq}
\end{figure}



